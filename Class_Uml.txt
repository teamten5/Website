@startuml
Class LevelType
LevelType --> Level : type
LevelType "1" -- "1..*" Combination : combinations[]
Chef "1..*" --* "1" Level : chefs[]
Station "0..*" --* "1" Level : stations[]
StationType "1" --> "0..*" StationLevel : type
StationLevel "1" --> "0..*" Station : stationLevel
Chef "0..*" <-- "0..1" ItemType : holding
LevelScreen --> Level : level

Controller --> Chef :controller
Order "0..*" --> "1" Level : orders[]
class Level {
-unactiveChefs
+update()
+render()
+closestStation(x, y)
+swapChefs(Chef, controller)
}

Order <-- OrderType
OrderType "0..*" <-- "1" ItemType : itemOrdered
OrderType : +placeOrder()

PlayerController --|> Controller

Class LevelType {

+instantiate()
}

LevelType "1" <-- "0..*" ChefAction : hashmap<>
LevelType "1" <-- "0..*" StationLevel : stations[]
LevelType "1" <-- "1..*" OrderType : ordertypes[]
class StationLevel {
position: Int
orientation
Instatiate()
}

Station "0..*" <-- "0..1" ItemType : holding

Class StationType{
+instantiate()
serving: bool

}
Class ChefAction{
time: int
ChefRequired: bool
pickupOutput: bool
read()
}


Class ItemType{
render()
update()
}



ChefAction "0..*" <-- "1" StationType : station
ChefAction "0..*" <-- "1" ItemType : input
ChefAction "0..*" <-- "1" ItemType : output



Class Combination{
+isValid()
}

ItemType "1" --> "0..*" Combination : startingChefHolding
ItemType "1" --> "0..*" Combination : startingOnStation
ItemType "1" --> "0..*" Combination : endingChefHolding
ItemType "1" --> "0..*" Combination : endingOnStation
Combination <-- StationType

Abstract Class Controller{
x: double
y: double
doAction: bool
doCombination: bool
swapChef: bool
update(float delta)
}
NullController --|> Controller
Class Chef{
render()
update()
}


Class Station{
chefDoingAction: bool
actionProgress: float
render()
update()
getHolding()
getAction()
setHolding()
doAction()
}

Station "0..*" <-- "1" ChefAction : currentAction
@enduml
